To begin, our application.py file contains the flask code necessary to run an actively changing web platform.

The foodsearch path first checks if the user actually inputted a food, and returns an error message if not. Given that the user inputted a food, the function will then query the database using a LIKE statement to find any instances of that food within the nutrition database. These results will then be passed to the HTML file, wherein each food item will then be iterated through and printed in a table along with its carbohydrate info. Through this function, the user can check to see if the foods that they have eaten exist within the database.

The addfoods path allows a user to enter a new food item that isn’t in the SQL database.  When a new food is entered, addfoods() first checks to see if the food item exists with a query search of the nutrition database containing all pre-existing foods.  If the food item already exists, a bootstrap alert warns the user that the food item exists.  If the food item doesn’t exist in the database, then a bootstrap alert pops up informing the user that the food item has been added.  Since jinja doesn’t work within javascript tags (jinja cannot be interpreted by js), the information must be serialized so that the data passed can be understood by javascript.  This is done using JSON, namely, the json.dumps() function.  A food_item variable containing food_item and a food_exists boolean is passed to the food_added javascript function, which returns the appropriate bootstrap alert depending on the user input.

In the enter foods HTML page, the user can input different food items eaten for a particular field.  Since any number of food items can be eaten for a particular meal, the food_input DIV has to be dynamic, so that the user can add any number of food items he or she wants.  Thus, a javascript function called add_item() was added, which gets the ul_food_input DIV class and adds another text and number input.  The add_item() has a variable called form_id which increments by 1 every time the function is called in order to give a distinct food_item and serving id to each new food item input field.

When the form is submitted with the submit button, application.py reads the food items and servings and adds it to a list of lists until there are no more food items (a request for a food_item id returns None).  A list of lists allows the food item and the serving to be stored in pairs (list of two values), which makes unpacking of data in the for loop iteration through food_items much easier.

Next, the total carbohydrate intake (total_carbs) is summed up by executing a query search for all the foods in food_items, and multiplying by the number of servings.  Enter_foods then calls a helper function called calculate, which takes in four parameters (weight, total carbs, actual blood sugar level, target blood sugar level).  They are used to calculate the base dosage and correct dosage of insulin needed to cover the carbohydrate intake and target and current blood sugar level differential.  The total dosage of insulin is returned to the entered_foods.html, and the food items are inputted into the history table.

The history path allows the user to view all of the food items that they have inputted, sorted by meal type (breakfast, lunch, dinner) and the date of meal, as well as the required insulin intake for that meal. We utilized a SELECT query to get the user’s food inputs from the history table in insulin.db, using the user’s ID and sorting by date and then meal. This information was then passed to the HTML template, which iterated through the data and displayed each input as a table entry.

We utilized the login/logout functions from the CS50 Finance PSET, and implemented a new register function. The register function checks that the user inputted both a username and password, where the password must have at least 8 characters and contain at least one uppercase letter/digit. Furthermore, the user must also input their weight as an integer. We implemented several error checking steps that note if the password confirmation matches the password, as well as if the user inputted a negative weight. Given that all of these fields are correct, the user’s information is then added to the users table in insulin.db using an INSERT query.

The info HTML file contains a description of the functionalities of this web platform, and links to all of the capabilities. The resource HTML file, similarly, contains descriptions of several common types of diabetes, and links to relevant online resources. If the user is unable to find their diabetes type, there is a Google search bar form that directly links the user to whatever query is inputted into the bar, allowing for the user to easily search for their diabetes type.

The styles.css file contains the style information for a majority of the elements in this platform, including the side navigation bar and the design elements for tables/forms/text elements.
